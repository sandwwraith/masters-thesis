\documentclass[specification,annotation,times]{itmo-student-thesis}

%% Опции пакета:
%% - specification - если есть, генерируется задание, иначе не генерируется
%% - annotation - если есть, генерируется аннотация, иначе не генерируется
%% - times - делает все шрифтом Times New Roman, собирается с помощью xelatex
%% - languages={...} - устанавливает перечень используемых языков. По умолчанию это {english,russian}.
%%                     Последний из языков определяет текст основного документа.

%% Делает запятую в формулах более интеллектуальной, например:
%% $1,5x$ будет читаться как полтора икса, а не один запятая пять иксов.
%% Однако если написать $1, 5x$, то все будет как прежде.
\usepackage{icomma}

%% Один из пакетов, позволяющий делать таблицы на всю ширину текста.
\usepackage{tabularx}

\usepackage{csvsimple}

\newcommand{\todo}[1]{\textbf{TODO}} %% useful

%% Данные пакеты необязательны к использованию в бакалаврских/магистерских
%% Они нужны для иллюстративных целей
%% Начало
\usepackage{tikz}
\usetikzlibrary{arrows}
\usepackage{filecontents}

\usepackage{csquotes}
\MakeOuterQuote{"}


%% Cтиль для листингов Kotlin (https://github.com/cansik/kotlin-latex-listing)
%% TODO: заслать туда PR с добавленными кейвордами

\lstdefinelanguage{Kotlin}{
  keywords={package, as, as?, typealias, this, super, val, var, fun, for, null, true, false, is, in, throw, return, break, continue, object, if, try, else, while, do, when, class, interface, enum, object, companion, open, override, final, public, private, get, set, import, abstract, vararg, expect, actual, where, suspend, data, internal, dynamic, by, constructor, annotation},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={@Deprecated, @JvmName, @JvmStatic, @JvmOverloads, @JvmField, @JvmSynthetic, @Serializable, @Target, @SerialInfo, @ProtoId},
  ndkeywordstyle=\color{BurntOrange}\bfseries,
  emph={println, return@, forEach, map, mapNotNull, first, filter, firstOrNull, lazy, delegate, T, field},
  emphstyle={\color{OrangeRed}},
  identifierstyle=\color{black},
  sensitive=true,
  commentstyle=\color{Emerald}\ttfamily,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  stringstyle=\color{ForestGreen}\ttfamily,
  morestring=[b]",
  morestring=[s]{"""*}{*"""},
}

%% Включаем Kotlin по умолчанию
\lstset{language=Kotlin}
\lstset{inputencoding=utf8x, extendedchars=\true}
%\lstset{basicstyle=\ttfamily}
\lstset{basicstyle=\ttfamily\small,breaklines=true}

\begin{filecontents}{master-thesis.bib}
@book{ jvm8-spec,
    author = {Lindholm, Tim and Yellin, Frank and Bracha, Gilad and Buckley, Alex},
    title       = {The Java Virtual Machine Specification, Java SE 8 Edition},
    publisher   = {Addison-Wesley Professional},
    numpages    = {600},
    pagetotal   = {600},
    year        = {2014},
    langid = {english},
}

@book{EcmaScript,
  added-at = {2012-10-14T23:50:22.000+0200},
  author = {{ECMA International}},
  edition = {5.1},
  interhash = {b179dfe8f7ed6ef5ad2a2c4705d88de6},
  intrahash = {a9b23a5e720836b2505b7aac7fdc4638},
  keywords = {ECMA JavaScript Specification Standard},
  month = jun,
  timestamp = {2012-10-14T23:50:23.000+0200},
  title = {Standard ECMA-262 - ECMAScript Language Specification},
  url = {http://www.ecma-international.org/publications/standards/Ecma-262.htm},
  year = 2011,
  langid = {english},
}

@online{rust-mut,
	url = {https://doc.rust-lang.org/1.0.0/book/mutability.html},
	title = {The Rust programming language},
	langid = {english},
	urldate = {2019-10-10}
}

@online{cpp-const,
	url = {https://docs.microsoft.com/en-us/cpp/cpp/const-cpp?view=vs-2019},
	title = {C++ language reference},
	langid = {english},
	urldate = {2019-10-10}
}

@online{js-deep-freeze,
	url = {https://www.npmjs.com/package/deep-freeze},
	title = {NPM --- deep-freeze},
	langid = {english},
	urldate = {2019-10-10}
}


@online{shipilev-final,
	url = {https://shipilev.net/blog/2014/safe-public-construction/#_safe_initialization},
	title = {Safe Publication and Safe Initialization in Java},
	langid = {english},
	urldate = {2019-10-10},
	year = 2014
}

\end{filecontents}
%% Конец

%% Указываем файл с библиографией.
\addbibresource{master-thesis.bib}

\DeclareFieldFormat{urldate}{%
(дата обращения:
\thefield{urlday}\adddot\thefield{urlmonth}\adddot\thefield{urlyear})%
}

\begin{document}

\studygroup{M4239}
\title{Разработка и внедрение глубоко неизменяемых объектов в языке Kotlin}
\author{Старцев Леонид Михайлович}{Старцев Л.М.}
\supervisor{Шалыто Анатолий Абрамович}{Шалыто А.А.}{проф., д.т.н.}{главный научный сотрудник Университета ИТМО}
\publishyear{2020}
%% Дата выдачи задания. Можно не указывать, тогда надо будет заполнить от руки.
\startdate{01}{сентября}{2018}
%% Срок сдачи студентом работы. Можно не указывать, тогда надо будет заполнить от руки.
\finishdate{31}{мая}{2020}
%% Дата защиты. Можно не указывать, тогда надо будет заполнить от руки.
\defencedate{15}{июня}{2020} %% todo: дата защиты

\addconsultant{Елизаров Р.А.}{магистр, без звания}

\secretary{Павлова О.Н.}

%% Задание
%%% Техническое задание и исходные данные к работе
\technicalspec{Требуется исследовать существующие возможности языка Kotlin для обеспечения глубокой неизменяемости объектов и контролирования владения объектами, проанализировать подходы к данной проблеме в других языках, и предложить возможности расширения синтаксиса языка и компилятора Kotlin для улучшения существующих способов работы с неизменяемыми объектами.}

%%% Содержание выпускной квалификационной работы (перечень подлежащих разработке вопросов)
\plannedcontents{\begin{enumerate}
	\item Сформулировать требования для корректного решения задачи.
	\item Исследовать механизмы для контроля изменяемости и владения объектами во время выполнения программы.
	\item Исследовать механизмы для контроля изменяемости и владения объектами во время компиляции программы.
	\item Предложить собственное решение проблемы с учетом сформулированных требований.
\end{enumerate}}

%%% Исходные материалы и пособия 
%% todo дописать
\plannedsources{\begin{enumerate}
    \item Исходный код компилятора Kotlin; в частности, существующие плагины к компилятору.
\end{enumerate}}

%%% Цель исследования
\researchaim{Разработка решения для языка Kotlin по обеспечению контроля за глубокой изменяемостью объектов и их владением.}

%%% Задачи, решаемые в ВКР
\researchtargets{\begin{enumerate}
    \item обеспечение контроля за глубокой изменяемостью объектов и их владением во время выполнения программы.
    \item обеспечение контроля за глубокой изменяемостью объектов и их владением во время компиляции программы.
    \item обеспечение обратной совместимости с уже существующими синтаксисом и семантикой языка.
    \item обеспечение должной производительности решения.
\end{enumerate}}

%%% Использование современных пакетов компьютерных программ и технологий
\addadvancedsoftware{Компилятор Kotlin и виртуальная машина HotSpot}{\ref{codegen}}
\addadvancedsoftware{Системы сборки Maven и Gradle}{\ref{codegen}}

%%% Краткая характеристика полученных результатов 
\researchsummary{Была разработана концпеция деления объектов в программе на разделяемые (неизменяемые) и не разделяемые (изменяемые). Был написан плагин к компилятору, который производит необходимые проверки на этапе компиляции, а также производит трансформацию кода, которая позволяет выполнять проверки во время выполнения скомпилированной программы.} 

%%% Гранты, полученные при выполнении работы 
\researchfunding{\textit{отсутствуют}.}

%%% Наличие публикаций и выступлений на конференциях по теме выпускной работы
\researchpublications{Участие в «VIII Конгрессе молодых учёных», прошедшем с 15 по 19 апреля 2019 года, с докладом: «Старцев Л.М., Шалыто А.А. Потенциал глубоко неизменяемых объектов в языке Kotlin».
}

%% Эта команда генерирует титульный лист и аннотацию.
\maketitle{Магистр}

%% Оглавление
\tableofcontents

%% Макрос для введения. Совместим со старым стилевиком.
\startprefacepage

Целью данной работы является разработка нового механизма для языка Kotlin, который бы позволил обеспечивать более точный контроль над неизменяемостью объектов.

В последнее время, в связи с широким распространением функционального программирования и распределённых систем, тема неизменяемых объектов становится всё более популярной.
Это связано в первую очередь с тем, что такие объекты сильно упрощают жизнь программиста: владение ими можно спокойно передавать между потоками, не опасаясь гонок данных, можно легко кэшировать результаты вычислений на неизменяемых объектах, не нужно производить сложную отладку, пытаясь понять, где изменилась та или иная переменная.

Если неизменяемость объектов встроена в язык, можно строить более понятные интерфейсы программирования библиотек, когда из одного модификатора изменяемости понятно, может ли клиентский код производить запись в переменную библиотеки или нет.

В первой главе данной работы рассматриваются существующие способы решения задачи в других языках, а также формируется набор требований к решению.

Во второй главе автор излагает архитектуру предлагаемого решения, описываются добавленные в язык семантические и синтаксические конструкции.

В третьей главе рассматриваются детали реализации рассматриваемого решения.


%% Начало содержательной части.
\chapter{Анализ задачи}

\section{Обзор языка Kotlin и проблемы в его контексте}\label{existing_kotlin}

Язык Kotlin, как и Java, уже поддерживает неизменяемые ссылки, они обозначаются ключевым словом \texttt{val} (аналог \texttt{final} переменной в Java\cite{jvm8-spec}). 
Однако, хоть такие ссылки и неизменяемые, они могут указывать на изменяемые объекты или объекты, содержащие изменяемые ссылки.
Примером данного поведения является \texttt{val} ссылка на изменяемый список: программист не может изменить значение ссылки, но может добавлять или удалять элементы в/из этого списка, что может приводить к гонкам данных, если ссылка на этот список была скопирована в соседний поток.
При этом, даже если ссылка имеет типа неизменяемого списка, если на тот же объект в памяти указывает ссылка с типом изменяемого списка, данный объект также может быть изменён, зачастую --- неожиданно для клиента.

Пример такого поведения показан на листинге \ref{mut_list}:

\begin{lstlisting}[float=h!,caption={Один список с разными типами ссылок},label={mut_list}]
val list1: MutableList<String> = mutableListOf("a", "b")
val list2: List<String> = list1
list1.add("c")
// list2.add("c") --- compiler error

println(list2 == listOf("a", "b")) // false
\end{lstlisting}

Другой распространенной ошибкой является случай, когда из метода класса возвращается ссылка на часть его изменяемых приватных данных, которые внешний клиент может поменять, нарушив тем самым инварианты класса.

Для решения таких проблем применяется отдельный паттерн, называемый "защитным копированием" (\textit{defensive copy}).

Следует отметить, что подобные проблемы в языке Kotlin можно решить, следуя этим правилам:

\begin{enumerate}
	\item Использовать только \texttt{val} ссылки в дереве объектов.
	\item Использовать интерфейсы коллекций только для чтения (\texttt{List} вместо \texttt{MutableList} или \texttt{ArrayList}).
\end{enumerate}

Однако данный стиль программирования сразу накладывает ограничения: запрет \texttt{var} приводит к невозможности создания рекурсивных/циклических структур и дорогому глубокому копированию при каждой необходимости изменения, а требование всегда возвращать \texttt{List} приводит к паттерну программирования "backing property":

\begin{lstlisting}[float=h!,caption={Backing property},label={backing_property}]
class WithPrivateList {
	private val _myList: MutableList<String>
	public val publicList: List<String> get() = _myList
}
\end{lstlisting}

Тем не менее, такой паттерн всё ещё может привести к некорректному доступу к данным, если "нечестный" клиент класса произведёт приведение интерфейса вниз или если попытаться воспользоваться этим классом из Java, так как разница между \texttt{List} и \texttt{MutableList} существует только для компилятора Kotlin, но не для виртуальной машины Java.
Кроме того, для пользовательских классов потребуется всегда заводить дополнительный интерфейс или два.

Таким образом, проблемой в контексте Kotlin является невозможность как-то более гранулярно ограничить доступ к изменению ссылок в дереве объектов, не 
делая их финальными для всех клиентов одновременно.

\section{Обзор существующих решений}
\startrelatedwork

В данном разделе рассмотрим, какие решения данной проблемы предлагают другие популярные языки программирования.

\subsection{\texttt{const} модификатор в C++}

В языке C++ есть \texttt{const} модификатор, который на первый взгляд может показаться аналогом \texttt{final} из Java, но это не так: используя const ссылку, невозможно изменить не только её, но и содержимое объекта, доступного по ней. Более того, методы классов в C++ тоже можно помечать как \texttt{const} \cite{cpp-const}, таким образом указывая, какие методы можно вызывать, имея const ссылку, а какие --- имея только обычную.
Таким образом, можно разделить API класса на изменяющий API и API только для чтения. При этом не нужно заводить какие-либо дополнительные интерфейсы, что выгодно отличает данный подход от пары интерфейсов \texttt{List} и \texttt{MutableList}, решающих ту же задачу.
При этом, разумеется, возможен сценарий, когда класс хранит обычную ссылку на объект, а наружу отдает только \texttt{const} ссылки, предоставляя другим классам доступ только для чтения.

Тем не менее, в языке C++ нет никакого контроля за количеством таких ссылок: можно иметь сколько угодно \texttt{const} и обычных ссылок на один и тот же объект. Может возникнуть ситуация, когда клиент, имеющий const ссылку на объект, может наблюдать изменения в этом объекте, если он был модифицирован другим клиентом, имеющим не-\texttt{const} ссылку: например, в \texttt{const}-списке может измениться число хранящихся элементов.
Поэтому объекты по таким ссылкам нельзя назвать по настоящему неизменяемыми; однако такой способ с разделением API на изменяющее и неизменяющее достаточно удобен.

\subsection{\texttt{mut} ссылки в Rust}

Язык программирования Rust также предлагает два типа ссылок: изменяемые и неизменяемые, причём, как и в C++, неизменяемость ссылки так же означает, что на этому объекте нельзя вызывать мутирующие методы и нельзя изменять его поля. При это все ссылки являются неизменяемыми по умолчанию, а чтобы обозначить ссылку как изменяемую, необходимо применить ключевое слово \texttt{mut} \cite{rust-mut}. 
Специальный механизм компилятора, называющийся \texttt{borrow checker}, умеет проверять, что в конкретной точке программы на конкретный объект указывает либо одна изменяемая ссылка, либо несколько неизменяемых.
Таким образом решается проблема, существующая в C++ и Kotlin: если клиент имеет на руках неизменяемую ссылку в Rust, он может быть уверен, что объект, доступный по ней, не будет изменён неожиданным образом, так как чтобы получить \texttt{mut} ссылку, необходимо, чтобы других ссылок на этот объект не было.
Данный паттерн называется \textit{Shared xor mutable} --- "Разделённый либо изменяемый".

Подход, принятый в Rust, решает много проблем, однако и требует много работы от программиста: доказать компилятору, что количество ссылок удовлетворяет нужным правилам, может быть непросто и может потребовать кропотливой работы с областями видимости переменных и/или временем их жизни (в Rust для этого применяется специальный синтаксис указания времён жизни -- \textit{lifetimes}).
Кроме этого, не любая логика программы удобно может быть выражена в таких терминах. Может получиться и так, что корректная программа не сможет удовлетворять выдвигаемым компилятором Rust требованиям.
В таких случаях авторы программ на Rust прибегают к использованию \texttt{unsafe} блоков, которые отключают проверки компилятора.
Если в программе всё-таки содержится ошибка, её поведение в этом случае становится неопределённым и может привести к трудным в воспроизведении и отладке проблемам.

\subsection{Заморозка объектов в JavaScript}\label{js_freeze}

В языке JavaScript существует функция \texttt{Object.freeze}, доступная в стандартной поставке \cite{EcmaScript}. Данная функция "замораживает" объект, запрещая ему добавлять новые свойства и изменять уже существующие.
Однако данная заморозка не является глубокой, т.е. не замораживает объекты рекурсивно, и получается, что она обладает всеми теми же недостатками, что и обычная ссылочная неизменяемость: ссылку в замороженном объекте поменять нельзя, а вот объект по ней --- можно.
Данную проблему решает свободно распространяемый пакет \texttt{deep-freeze}, доступный для скачивания в репозитории NPM\cite{js-deep-freeze}. Этот пакет вызывает \texttt{Object.freeze} рекурсивно на заданном объекте.

Тем не менее, к недостаткам данного решения можно ещё отнести и то, что замороженный объект не бросает каких-либо исключений при попытке его изменить: все модифицирующие операции просто не имеют эффекта и никак не уведомляют пользователя об этом, что может привести к трудноотлаживаемым логическим ошибкам в программе. Кроме того, поскольку JavaScript является интерпретируемым, а не компилируемым языком, нет никакой возможности отследить такие операции на замороженных объектах заранее, или вообще точно сказать, является ли изменяемым или замороженным объект в каком-то конкретном месте программы, посмотрев на её код.

\section{Требования к решению}

Для начала следует отметить, что предлагаемое решение не должно нарушать обратную совместимость языка Kotlin, то есть не должно иметь требования переписать уже существующий пользовательский код. Однако, система может просто не включаться или работать не в полную мощность на уже существующем коде.

Теперь разберем, в какой же момент должно срабатывать решение. Существующие решения можно разделить на две большие категории: проверки времени компиляции и проверки времени исполнения.
Выделим их плюсы и минусы:

\textbf{Проверки времени компиляции} --- предоставляют возможность раннего обнаружения ошибок в коде. Такие проверки обычно делаются с помощью системы типов или аналогичного механизма (например, lifetimes в Rust).
Однако, можно заметить, что чем мощнее такая система, тем труднее программировать с её помощью --- "заткнуть" ошибки компиляции с помощью добавления \texttt{const} в C++ проще, чем отслеживать и правильно выставлять lifetimes в Rust.
Кроме того, такие системы не идеальны и не могут доказать корректность кода с определенной структурой, что приводит к появлению \texttt{unsafe} блоков (Rust) или \texttt{reinterpret\_cast} к не-константным указателям или ссылкам (С++).

\textbf{Проверки времени исполнения} --- очевидно, обнаруживают ошибки позднее, а также могут приводить к аварийным завершениям программы, что может негативно сказаться на пользовательском опыте.
Однако они позволяют точно сделать вывод о том, можно ли изменять в данный момент конкретный объект или нет.
К тому же, падение программы при попытке изменения данных всё ещё лучше, чем неопределенное поведение или их ошибочное изменение.  

По результатам исследования и сравнения существующих решений можно сделать вывод, что перечисленные подходы имеют как свои достоинства, так и недостатки.
Имеет смысл попытаться объединить их, взяв лучшее и нивелировав худшее. В данной работе будет рассмотрен именно такой подход.


\section{Существующие предпосылки: заморозка}

Как было рассмотрено в разделе \ref{existing_kotlin}, в языке Kotlin уже есть ограниченные механизмы для управления неизменяемостью ссылок.
Кроме них, отправной точкой в исследовании может стать ещё один механизм, специфичный для Kotlin/Native из-за особенностей его модели памяти, а именно механизм заморозки объектов, похожий на рассмотренный в разделе \ref{js_freeze}.
Данный механизм представлен функцией-расширением на любом объекте: \texttt{fun Any.freeze()}.
После вызова данной функции, весь подграф объектов замораживается и становится недоступным для изменения.
Любые попытки изменить \texttt{var} переменные в этом подграфе приводят к выбросу исключения \texttt{InvalidMutabilityException} во время исполнения программы.
Данный механизм нужен для того, чтобы безопасно передавать данные между потоками и чтобы упростить работу сборщика мусора, основанного на счетчике ссылок.

На первый взгляд, данный механизм является решением предлагаемой проблемы, однако у него есть множество недостатков.
Главным недостатком является то, что функция \texttt{freeze} сама по себе является мутирующей, то есть, она изменяет состояние самого объекта, а не возвращает его замороженную копию.
Данное поведение функции не позволяет работать с этим объектом в дальнейшем:

\begin{lstlisting}[caption={Заморозка изначального объекта}]
val data1 = MyData()
val data2 = data1

data1.freeze()
shareToAnotherThread(data1)

data2.x = 42 // InvalidMutabilityException
\end{lstlisting}

После заморозки объекта, у его владельца не остается ссылки на его изменяемую версию, если он его заранее не скопировал.
Однако копирование целого подграфа объектов –-- достаточно объемная с точки зрения написания однотипного кода задача (исключением является автосгенерированный метод \texttt{copy} у data-классов, однако далеко не любой класс может сделать data-классом).

Следующим важным недостатком данного подхода является то, что он труден в отладке.
\texttt{InvalidMutabilityException} выбрасывается в момент попытки изменения данных, что может произойти в одном месте программы, хотя объект был изначально заморожен в совершенно другом месте, и установить, когда был заморожен конкретный объект, почти невозможно.
В каком-то смысле это "бомба замедленного действия", похожая на проблему \texttt{NullPointerException} в Java, именно с которой и борется Kotlin.

Таким образом, хоть данное решение и не идеально, его можно взять за отправную точку, улучшая и избавляя от недостатков. Задачи, которые предстоит решить:

\begin{enumerate}
	\item Обобщить решение с Kotlin/Native до Kotlin/JVM и Kotlin/JS.
	\item Решить проблему неудобства копирования.
	\item Решить проблему неочевидности \texttt{InvalidMutabilityException}.
\end{enumerate}


%% Так помечается начало обзора.

%Пример ссылок в рамках обзора: \cite{example-english, example-russian, unrestricted-jump-evco, nsga-ii-steady-state}.
%% Так помечается конец обзора.
\finishrelatedwork
%Вне обзора:~\cite{bellman}.

\chapterconclusion

В данной главе был произведен анализ проблем, которые будут решаться в рамках данной работы: отсутствие глубокой ссылочной неизменяемости в языке Kotlin и невозможность удобно представлять объект класса как доступный только для чтения без написания дополнительного интерфейса к нему (по аналогии с \texttt{List} и \texttt{MutableList}).

Также, в данной главе был произведен сравнительный анализ существующих решений, и сформулированы основные требования к разработке:

\begin{enumerate}
	\item Решение должно быть до определенной степени обратно совместимо с существующим синтаксисом языка.
	\item Решение должно производить как проверки времени компиляции, так и времени исполнения. При этом проверки времени компиляции могут быть достаточно строгими, чтобы обнаруживать наиболее распространенные классы ошибок, и достаточно нестрогими, чтобы программистам не приходилось долго "уговаривать" компилятор.  % todo вординг
	\item В качестве отправной точки можно использовать концепцию заморозки в Kotlin/Native, решив её проблемы.
\end{enumerate}

\chapter{Теоретическое исследование и разработка архитектуры}

\section{Обзор предлагаемого решения}\label{overview}

Предлагаемое в данной работе решение дорабатывает механику заморозки, делая её удобной для пользователей.
Для начала необходимо несколько расширить понятие владения объектом.
В модели памяти Kotlin/Native и в механизме заморозки считалось, что объектом/подграфом объектов владеет какой-либо поток.
В данном исследовании пока что примем, что один объект владеет другим объектом, если он применяет по отношению к нему паттерн "backing property" (см. листинг \ref{backing_property} --- в нём экземпляр \texttt{WithPrivateList} владеет \texttt{\_myList}). В дальнейшем (см. раздел \ref{compile_checks}) это определение будет уточнено.

Система, предложенная автором для решения поставленной задачи --- концепция \textbf{разделяемых} объектов (от англ. \textit{share} --- поделиться, разделить).
Все классы в программе поделены на три категории:
\begin{enumerate}
	\item Неразделяемые.
	\item Разделяемые по ссылке.
	\item Разделяемые по значению.
\end{enumerate}

Данное свойство присваивается классу программистом на этапе написания класса, то есть во время выполнения программы классы или их экземпляры не могут переходить из одной категории в другую.

\textbf{Неразделяемые} объекты --- это те объекты, про которые неизвестно, насколько безопасно передавать ссылку от владельца кому-нибудь ещё.
Такие объекты либо вообще не предназначены для передачи, либо передаются, но система за ними не следит (см. \ref{backwards_compat}).

\textbf{Разделяемые по ссылке} --- объекты, которые можно передавать по ссылке между разными владельцами или потоками.
Под эту категорию подходят изначально неизменяемые классы, например, \texttt{String}, \texttt{Int}, или \texttt{ImmutableList}.

\textbf{Разделяемые по значению} --- объекты, которые могут находиться в двух состояниях: эксклюзивном и разделенном. Могут содержать \texttt{var} ссылки.
В эксклюзивном состоянии они являются обычными изменяемыми объектами.
Однако при переходе в разделенное состояние все ссылки в подграфе такого объекта становятся неизменяемыми (аналогично заморозке).
Это, во-первых, позволяет сначала создать циклическую структуру и только потом сделать её неизменяемой (в отличие от классов только с \texttt{val}),
а во-вторых, если при запросе разделения объекта будет возвращаться разделенная копия, что позволит её владельцу оставить у себя эксклюзивную копию.

\subsection{Замечание про синтаксис}\label{syntax_note}

Для разметки классов по категориям разделяемости, в работе предлагается использовать специальные аннотации \texttt{@Shared} для разделяемых по значению объектов и \texttt{@SharedByValue} для разделяемых по ссылке.
Несмотря на то, что более логичным выглядит введение новых ключевых слов в язык, решение с аннотациями было выбрано по нескольким причинам:

\begin{enumerate}
	\item Аннотации могут быть добавлены на уровне библиотеки времени выполнения, в то время как ключевые слова требуют значительного изменения парсера в компиляторе.
	\item Аннотации могут быть легко переименованы с помощью стандартного для Kotlin механизма объявления деклараций устаревшими с заменой (\textit{deprecation with replacement}).
	\item Аннотации могут быть легко проигнорированы компилятором, если соответствующий плагин компилятора, отвечающий за их обработку, отключен.
\end{enumerate}

\section{Проверки времени исполнения}

\subsection{Обобщение механизма заморозки}

Механизм заморозки, выбрасывающий исключение при попытке изменения \texttt{var} поля у замороженного объекта, использует тот факт, что в Kotlin/Native среда времени выполнения (рантайм) предоставлена самим языком и встраивается во время компиляции.
В случае Kotlin/JVM и Kotlin/JS это не так –-- и JVM, и JS выполняются на виртуальных машинах, предоставленных сторонними разработчиками.
Поэтому, для реализации механизма разделения объектов, необходимо отказаться от встраивания в рантайм и попытаться встроить подобный механизм на этапе компиляции.

Для этого достаточно совершить следующую трансформацию над кодом: 

\begin{enumerate}
	\item Добавить свойство логического типа \texttt{isReadOnly}, невидимое для пользователя.
	\item В каждом сеттере проверять это свойство, и если оно \texttt{true}, бросать исключение.
\end{enumerate}

\begin{lstlisting}[float=h!,caption={Код до и после трансформации}]
@Shared
class Mutable {
	var value: String = "abc"
}

class MutableTransformed {
	/*synthetic*/ var isReadOnly: Boolean = false
	var value: String = "abc"
		set(v) {
			if (isReadonly) throwIME() 
			field = v
		}
}
\end{lstlisting}

\subsection{Замена функции \texttt{freeze}}\label{def_share}

Наивная реализация функции \texttt{freeze} с учетом вышеописанной трансформации выглядела бы так: нужно сначала пройтись по всем полям, выставить у них флаг \texttt{isReadOnly}, а затем выставить флаг у самого объекта.
Однако данная реализация не избавилась от своих недостатков, так как она изменяет объект, на котором вызвана.

Правильным решением будет не использовать функцию \texttt{freeze} вовсе, а заменить её на новую. Новая функция называется \texttt{share} и она определена на самом объекте, при условии, что он может быть разделен по значению, а не на \texttt{Any}.

\texttt{share} должна возвращать копию объекта в разделенном состоянии, если исходный объект был в эксклюзивном, или не делать ничего, если объект уже разделен и вернуть его же.
Получается, что сигнатура \texttt{share} имеет вид \texttt{fun T.share(): T}, где T является не переменной типа, а каким-то конкретным типом, т.е. функция \texttt{share} является не обобщенной, а методом конкретного класса.

% todo: спросить у Ромы про циклы
Алгоритм перевода объекта в разделенное состояние не сильно усложняется по сравнению с алгоритмом заморозки:

\begin{enumerate}
	\item Для каждого объекта Б, доступного по ссылке из A, получить его разделенную копию Б':
	\begin{enumerate}
		\item Если Б --- разделяемый по значению объект, вызвать его метод \texttt{share}.
		\item Если Б --- разделяемый по ссылке объект, взять ту же самую ссылку.
		\item Если Б --- неразделяемый объект, то получить для него разделённую копию невозможно. (см. раздел \ref{shared_requirements})
%		\item бросить исключение или поступить с ним так же, как с разделяемым по ссылке, в зависимости от настроек совместимости (см. \ref{backwards_compat}).
	\end{enumerate}
	\item Скопировать объект А c новыми значениями ссылок, указывающими на Б'.
\end{enumerate}

Реализация \texttt{share} может выглядеть следующим образом:

\begin{lstlisting}[float=h!,caption={Реализация share}]
@Shared
class Mutable {
	var value: String = "abc"
	var another: AnotherMutable = /*...*/
	
	/*synthetic*/ fun share(): Mutable {
		if (this.isReadOnly) return this
		val copy = this.copy(this.value, this.another.share())
		copy.isReadOnly = true
		return copy
	}
}
\end{lstlisting}

Следует отметить, что реализация метода \texttt{share} требует наличия у класса метода \texttt{copy}.
Однако, это не означает, что \texttt{@Shared} класс обязан быть \texttt{data}-классом.
Реализация метода copy может быть сгенерирована специально для метода \texttt{share} (см. \ref{codegen}).
Разумеется, если класс уже является \texttt{data} или \texttt{@Serialiazble}, можно взять уже существующий метод \texttt{copy} или \texttt{copy}-конструктор.

\subsection{Облегчение отладки}

Для облегчения отладки причин \texttt{InvalidMutabilityException} при вызове функции share можно сохранять, в каком месте произошел этот вызов.
Сделать это очень просто: достаточно создать новое исключение, не бросая его, и запомнить его (например, записать в приватное синтетическое свойство класса, точно так же, как флаг \texttt{isReadOnly}).
В дальнейшем, при создании \texttt{InvalidMutabilityException}, сохраненное исключение можно добавить как причину, вызвавшую IME (\texttt{addCause()} в терминах JVM).
Тогда пользователь увидит не только стектрейс, где произошла попытка изменения, но и стектрейс, где впервые был вызван \texttt{share}.

Следует отметить, что создание исключения и стектрейса на каждый вызов \texttt{share} --- не самая дешёвая с точки зрения производительности операция.
К тому же, описываемая функциональность нужна не всегда. Поэтому разумным будет добавить возможность контролировать данное поведение с помощью системной переменной, которую можно конфигурировать при запуске виртуальной машины Java логическим аргументом \texttt{-Dkotlinx.sharing.debug}.

\section{Проверки времени компиляции}\label{compile_checks}

Функция \texttt{share} уже решает достаточно большое количество задач: позволяет использовать паттерны "defensive copy" и "backing property" со всеми \texttt{@Shared} объектами, а не только с коллекциями; позволяет относительно безопасно передавать объекты между потоками; позволяет одному владельцу изменять объект, а всем остальным только читать его.
Однако состояние разделенности/эксклюзивности объекта всё ещё является свойством времени выполнения и обладает всеми недостатками таких механизмов. 
Поэтому стоит разработать какой-то механизм для этапа компиляции, который бы мог предупредить программиста о том, что в конкретном месте программы может быть выброшен \texttt{InvalidMutabilityException}.

Стоит отметить, что автор данной работы не пытается построить новую систему типов или аналогичный механизм, который бы давал 100\% гарантии.
Цель предлагаемых проверок компилятора --- снизить количество типичных ошибок до минимума, и, как следствие, уменьшить количество IME в рантайме.
Но в каких-то сложных случаях не следует опасаться того, что компиляторная проверка не сработает,
так как во время рантайма будет дополнительная защита от повреждения данных.

\subsection{Требования к разделяемым классам}\label{shared_requirements}

Рассмотрим, что требуется от класса, для того чтобы он мог иметь аннотацию \texttt{@Shared} или \texttt{@SharedByValue}.
Начнем с разделяемых по значению объектов.
Исходя из предложенного в разделе \ref{def_share} алгоритма для
\texttt{share}, заметим, что для того, чтобы эта функция работала корректно,
все типы свойств в классе должны быть разделяемыми.
Для данного свойства можно добавить проверку на этапе компиляции, что и было сделано в данной работе.
Таким образом, если в разделяемом  по значению классе есть свойства, типы которых не разделяемы, пользователю в таком случае при компиляции показывается ошибка.

Несколько другая ситуация с классами, разделяемыми по ссылке. Согласно определению из раздела \ref{overview}, они должны быть неизменяемыми.
Добиваться такого поведения от класса можно разными способами, при этом не все из таких способов могут быть проконтролированы компилятором.
Кроме того, возможна ситуация, когда даже изменяемым объектом всё равно требуется поделиться --- например, если он обладает свойством потокобезопасности или другим необходимым доменно-специфичным свойством.
Поэтому обязанность по контролю за такими классами остается на пользователе --- компилятор никак не будет проверять, правда ли, что класс, проаннотированный как \texttt{@SharedByValue}, действительно неизменяемый.

\subsection{Владение объектами}

Для вышеупомянутых целей подойдет достаточно простая модель владения объектами. Пусть у нас есть класс А, который является разделяемым по значению.
Объект класса Б владеет объектом класса А, если одно или больше условий из списка выполнено:

\begin{enumerate}
	\item Класс Б разделяем по значению и в нем есть свойство типа А. %todo: нужна ли приватность?
	\item Класс Б имеет приватное свойство типа А, помеченное аннотацией \texttt{@Owned}.
\end{enumerate}

Данное свойство распространяется на подграф транзитивно.

Первое условие соответствует интуитивной логике "разделяемый объект владеет своими разделяемыми данными", а второе условие позволяет эффективно использовать паттерны defensive copy/backing property.

\subsection{Требования к владельцам классов}

Считается, что если Б владеет А, то А представляет собой приватное изменяемое состояние Б.
В таком случае, логично ожидать от Б, что он не будет отдавать А наружу в изменяемом состоянии.
Компилятор по мере своих сил должен проверять это: в случае, если Б из какого-либо метода возвращает экземпляр А, то он должен сначала вызвать на нём \texttt{share}.
Таким образом, на уровне компиляции закрепляется паттерн defensive copy.
Следует отметить, что так как владение распространяется на весь подграф транзитивно, то для того, чтобы вернуть часть A, тоже нужно вызвать share на этой части или на всём А.

\subsection{Ограничения для клиентов класса, не являющихся владельцами}

Если не-владелец класса попытается изменить какое-то \texttt{var} поле в разделяемом по значению классе, он должен получить предупреждение компилятора о том, что в данном месте может возникнуть \texttt{InvalidImmutabilityException}.

\subsection{Передача владения}

Тип \texttt{А} может иметь аннотацию \texttt{@Owned} в месте использования: в параметрах функции или её возвращаемом типе. В таком случае, компиляторные проверки отключаются.

Таким образом, отношения между ссылкой типа \texttt{А} и ссылкой типа \texttt{@Owned A} напоминают отношения между типами \texttt{List} и \texttt{MutableList}: они могут указывать на один и тот же объект, но только имея вторую ссылку, можно его изменять.

Следует отметить, что программист может создать две \texttt{@Owned} ссылки или пометить два свойства как \texttt{@Owned} и присвоить одно другому. В таком случае вполне возможна гонка данных между потоками. Это не считается ошибкой и остается ответственностью программиста.
Точно так же не считается ошибкой, если в \texttt{@Owned} свойстве оказался объект в уже разделенном состоянии.

\section{Совместимость с существующим кодом на Kotlin}\label{backwards_compat}

Те классы, которые не помечены \texttt{@Shared} или \texttt{@SharedByValue}, обычно игнорируются в предлагаемой работой системе.
Получается, что весь старый код будет работать так, как и работал.
Если поля таких типов попытаться добавить в \texttt{@Shared} класс, можно получить ошибку компиляции, т.к. сгенерировать метод \texttt{share} будет невозможно.
Однако, это может быть неудобно при миграции больших классов-состояний на новую систему.
В таком исключительном случае можно заставить систему думать о том, что такие классы на самом деле \texttt{@SharedByValue}, оставляя ответственность на программисте.

\chapterconclusion

В данной главе была изложена архитектура предлагаемого решения и описаны предлагаемые изменения в языке.
Были описаны аспекты предлагаемого решения: трансформации кода, которые бы обеспечивали неизменяемость классов во время выполнения, замена функции \texttt{freeze} на \texttt{share}, а так же проверки на этапе компиляции, которые бы помогали предотвратить появление исключения во время выполнения при попытке поменять свойство неизменяемого (разделённого) экземпляра класса.
Были изложены соображения про то, как, не ломая синтаксис языка, внести новую семантику с помощью аннотаций.

\chapter{Детали реализации}

%\section{Флаги объекта}

%\todo{}

\section{Копирование объектов и их идентичность}

Одним из важных свойств класса, участвующего в операции \texttt{share()}, является возможность его скопировать: действительно, после того, как у всех его свойств был вызван \texttt{.share}, нам необходимо вернуть его новую копию, в которой будут обновленные и уже разделенные свойства.
Однако не любой класс в программе можно скопировать, т.к. ни в одной из целевых платформ Kotlin нет нативно поддерживающейся операции "клонирование объекта" или "клонирование области памяти". Да, можно вспомнить про интерфейс \texttt{java.lang.Cloneable} или класс \texttt{sun.misc.Unsafe}, но, во-первых, на данный момент они считаются не рекомендованными для использования и устаревшими, а во-вторых, доступны только на JVM.

Поэтому разделяемому по значению классу необходимо так же определить стратегию копирования. Данную задачу неразумно возлагать на пользователя, так как помимо добавления одной аннотации \texttt{@Shared} ему придётся ещё писать излишний и однообразный код метода \texttt{copy()}.
К счастью, в языке Kotlin уже давно есть определенный набор классов, у которых всегда есть метод \texttt{copy} --- data-классы. К классам, помеченным таким модификатором, компилятор автоматически генерирует методы \texttt{copy}, \texttt{equals}, \texttt{hashCode} и методы для позиционного деструктурирования (\texttt{componentN}).
Поэтому именно data-классы очень легко сделать разделяемыми по значению.

Однако у data-классов есть ряд ограничений: например, они не могут иметь наследников. Вполне вероятна ситуация, когда пользователю захочется сделать класс разделяемым по значению, но этот класс будет нежелательно трансформировать в data-класс.
В таких ситуациях возможно сгенерировать только метод \texttt{copy} (по аналогии с методом \texttt{share}), не превращая класс в data.
При этом вообще необязательно делать \texttt{copy} именно методом, можно сгенерировать сразу копирующий конструктор.
То есть, если аннотацией \texttt{@Shared} помечен data-класс, то в нём генерируется реализация \texttt{share} и используется существующий метод \texttt{copy}, а если такой же аннотацией помечен обычный класс, то в нём генерируется реализация и копирующего конструктора, и \texttt{share}.

Тем не менее, в качестве разделяемых по значению классов всё ещё лучше использовать обычные data-классы по причине того, что у них корректно определён \texttt{equals} и \texttt{hashCode}. Семантика Kotlin, как и JVM, предполагает, что если у класса не определены эти методы, то экземпляры классов сравниваются по идентичности, т.е. экземпляр может быть равен только самому себе.
Вспоминая, что при вызове \texttt{share} объект копируется, получится, что если у класса не определен \texttt{equals}, то его копия, полученная после вызова \texttt{share}, будет не равна оригиналу, т.е. логические выражения \texttt{a.share() == a} и \texttt{a.share() == a.share()} будут иметь результат \texttt{false}.
Такое поведение может вызывать неожиданный результат и приводить к трудноотлаживаемым ошибкам в программе, поэтому одной из рекомендаций при использовании описываемой в работе системы является "определяйте \texttt{equals} и \texttt{hashCode} у ваших \texttt{@Shared} классов или используйте data-классы".


\section{Разрешение циклических зависимостей и реализация \texttt{share}}

В методе \texttt{share} выполняется глубокое копирование объектов. При наивной реализации такого копирования могут возникнуть следующие ситуации и проблемы:

\begin{enumerate}
	\item \label{cyclic} Циклическая ссылка в подграфе объектов --- объект А содержит ссылку на объект Б, а объект Б содержит ссылку на объект А. В таком случае, при наивной реализации глубокого копирования может возникнуть ошибка переполнения стека.
	\item \label{rombic} Ромбовидная ссылка --- объект А содержит ссылку (прямую или через другие объекты) на объекты Б1 и Б2, каждый из которых содержит ссылку на объект В. При копировании А, Б1 и Б2 будут скопированы независимо, а следовательно, вместо одного объекта В у нас получится две его независимые копии, что приведет к увеличенному потреблению памяти и возможности ошибки "недостаточно памяти в куче" при большом количестве таких ситуаций.
\end{enumerate}

Для решения описанных проблем необходимо применять не наивную реализацию,
а такую, которая могла бы корректно работать с циклическими подграфами объектов.
Для этого подходит алгоритм поиска в глубину: с помощью данного алгоритма можно отмечать уже посещенные объекты и те, в процессе копирования которых мы сейчас находимся.
Также, необходимо запоминать, какому из оригинальных объектов какой скопированный объект соответствует, чтобы решить проблему \ref{rombic}). 
Можно заметить, что в качестве отметки о "посещении" объекта может служить как раз его новая копия.
Таким образом, для запоминания состояния обхода в глубину был выбран \texttt{IdentityHashMap<Any, Any?>}, где в качестве ключей выступают элементы графа -- оригинальные объекты, а в качестве значений их новые копии или \texttt{null}, если данный объект ещё не был скопирован.
Очевидно, что асимптотика затрат памяти при этом не ухудшилась.

Реализация метода \texttt{share} при этом разделится на две, как показано на листинге \ref{share_impl}.
"Оригинальный" метод \texttt{share} будет по-прежнему выступать в качестве пользовательского API и не содержать лишних параметров, а метод \texttt{shareImpl} будет работать со словарём -- деталью реализации и не должен быть показан пользователю.

\begin{lstlisting}[float=h!,caption={Усовершенствование share},label={share_impl}]
@Shared
class Mutable {
  fun share() = shareImpl(IdentityHashMap())
    
  fun shareImpl(dfsState: MutableMap<Any, Any>) : Mutable {
    if (this.isReadOnly) return this
	if (this in dfsState) return dfsState[this] as Mutable
	val copy = 
	  this.copy(this.value, this.another.shareImpl(dfsState))
	copy.isReadOnly = true
	dfsState[this] = copy
	return copy
  }
}
\end{lstlisting}

Данный подход решает проблему \ref{rombic}, но не решает проблему \ref{cyclic}, так как запись в словарь \texttt{dfsState} возможна только после полной инициализации копии.
Решить проблему цикличных ссылок можно двумя способами. Первый из них --- запретить их вообще. Для этого необходимо завести специальный объект, например \texttt{object CYCLE}, и помещать его в словарь по ключу \texttt{this} перед началом копирования.
Тогда при проверке \texttt{this in dfsState} достаточно отдельно рассмотреть случай, когда значение в словаре является \texttt{CYCLE}, и бросить исключение времени выполнения.
Несмотря на запрет циклов в подграфе объектов, рассматриваемое в работе решение по-прежнему может быть полезным, так как циклы в реальных приложениях встречаются не очень часто.

Если всё-таки требуется поддержать циклические ссылки, можно применить другой подход.
Для этого обязательно потребуется сгенерировать классе копирующий конструктор, который будет принимать параметры \texttt{dfsState} --- состояние обхода в глубину и \texttt{oldThis} --- объект, который требуется скопировать и который служит ключом в словаре состояния.
Тогда запись \texttt{dfs[oldThis] = this} можно будет произвести до непосредственного процесса копирования. Соответственно, в процессе копирования в словаре состояния уже будет доступно новое значение.

Кроме того, предложенный подход с использованием конструктора копирования решает ещё одну проблему, связанную с исполнением в многопоточной среде в JVM.
В реализации \texttt{share}, приведённой на листинге \ref{share_impl}, запись свойства \texttt{copy.isReadOnly = true} не защищена никаким барьером памяти.
Это означает, что при небезопасной публикации экземпляра, полученного из \texttt{share}, в другой поток, этот поток может не увидеть изменения в свойстве \texttt{isReadOnly}, а следовательно, сможет изменять другие свойства этого экземпляра.
Поэтому экземпляры разделяемых по значению классов, полученных с помощью обычной функции копирования, необходимо публиковать в другие потоки исключительно безопасным образом.
Если же используется копирующий конструктор, поле свойства \texttt{isReadOnly} может быть помечено как \texttt{final} в JVM, а значит,
при выходе из конструктора виртуальной машиной будет вставлен барьер памяти \cite{shipilev-final}.
Так как \texttt{this} до завершения конструктора используется исключительно в качестве ключа в словаре локального состояния обхода в глубину и не передаётся в другие потоки, то после завершения конструктора и окончания работы функции \texttt{share} на новый экземпляр класса будет указывать только ссылка, полученная как результат завершения конструктора и этой функции, а следовательно, любой из потоков будет видеть корректное значение свойства \texttt{isReadOnly}.
%
%\todo{gray state} 



\section{Разделяемые классы и наследование}\label{inheritance}

Рассмотрим возможность наследования разделяемых классов.
Неразделяемые и разделяемые по ссылке классы не нужно глубоко копировать, поэтому никаких проблем с тем, могут ли они реализовывать интерфейсы или наследоваться от других открытых или абстрактных классов, не возникает.
Другая ситуация с разделяемыми по значению классами: им требуется возможность копирования, а значит, если они наследуются от какого-либо класса, всё состояние предка так же нужно уметь копировать.
Следовательно, естественным образом вытекает требование на то, что разделяемые по значению классы могут наследоваться только от также разделяемых по значению классов.
Если бы данного требования не было, то, во-первых, было бы непонятно, как скопировать состояние предка при вызове \texttt{.share()}, а во-вторых, в предке могли бы содержаться изменяемые поля, которые были бы доступны на изменение в конкретном экземпляре наследника, даже если он находится в уже разделенном состоянии --- ведь сеттеры предка не проверяют состояние объекта.
Единственным исключением из этого правила будет класс \texttt{Any}, потому что он должен являться предком для любого класса. В данном случае это не вызовет проблем, так как \texttt{Any} не имеет никакого изменяемого состояния и не требует какой-то логики при копировании.

% todo: обговорить этот момент
Теперь рассмотрим возможность других классов наследоваться от разделяемых.
Проблема остается такой же: при добавлении в наследника изменяемого поля и последующем приведении его к типу предка, мы можем получить неожиданный результат, думая, что контролируем изменяемость этого типа.
 В данном случае наследование выглядит опасно и для разделяемых по значению классов, и для разделяемых по ссылке.
 Однако в рассматриваемой в работе системе разделяемость по ссылке считается неким свойством, задаваемым пользователем, и никак не проверяющимся компилятором --- т.е. если пользователь пометил изменяемый класс как разделяемый по ссылке, значит, в программе уже есть потенциальная логическая ошибка или гонка данных, и компилятор не сможет с этим ничего сделать.
 Поэтому запрет на наследование от разделяемого по ссылке класса вряд ли уменьшит количество ошибок. В данном случае разумно выдавать обычное предупреждение, заставляющее пользователя задуматься о том, является ли класс-наследник так же неизменяемым.
 
 Другая ситуация с классами, разделяемыми по значению: они трансформируются компилятором и могут порождать ошибки как на этапе компиляции, так и во время выполнения.
 Поэтому чтобы дальше усилить контроль над такими классами, разумно запретить наследование от этих классов любых других, не являющихся разделяемыми по значению. Таким образом, любой из сеттеров в иерархии будет трансформирован и сможет выбросить исключение, если на конкретном экземпляре до этого был вызван \texttt{.share()}.
 
 Если теперь начать рассматривать интерфейсы, может показаться, что вышеупомянутые ограничения не нужны: интерфейсы не имеют состояния и не требуют какой-то логики копирования, поэтому реализовывать их могут как и обычные, так и разделяемые классы.
 Однако, может возникнуть такая ситуация, при которой возникает желание использовать интерфейс в качестве типа свойства разделяемого по значению класса.
 Правила при этом требуют, чтобы этот интерфейс также был помечен как разделяемый, поэтому логично дать пользователю такую возможность.
 Это не повлияет на сам интерфейс, но включит все связанные с этим проверки классов-реализаций, т.е. если интерфейс помечен как разделяемый по значению, все его реализации обязаны быть разделяемыми по значению, а если интерфейс помечен как разделяемый по ссылке, будет показано предупреждение о том, что реализацию так же нужно пометить как разделяемую по ссылке (и самостоятельно убедиться в том, что это желаемая семантика для реализации).


\section{Разделяемые коллекции}\label{collections}


До этого в данной работе рассматривались классы, которые были самостоятельно размечены пользователем, как разделяемые.
Так как композиция разделяемых классов тоже может быть разделяемым классом, то на основе данного механизма уже можно строить доменно-специфичные модели в пользовательской программе.
Однако остается одно большое ограничение: коллекции. Так как они не подконтрольны пользователю и находятся в стандартной библиотеке, он не может пометить их как разделяемые, а следовательно, не может использовать их в разделяемых классах.

Первое, что приходит в голову при попытке решить данную проблему --- пометить сами классы коллекций как разделяемые.
Это решение, однако, не подходит по следующим причинам:

\begin{enumerate}
	\item Пометить одну из реализаций, например, \texttt{ArrayList}, явно недостаточно, так как в соответствии с хорошими практиками кодирования пользователи будут использовать в качестве типа интерфейс \texttt{List}, а не его реализацию.
	\item Если пометить сам интерфейс \texttt{List} как разделяемый по значению, то в соответствии с правилами из раздела \ref{inheritance}, все его реализации также должны будут стать разделяемыми по значению, что в случае некоторых конкретных реализаций будет проблематично или вообще невозможно сделать.
	\item Внесение таких изменений в стандартную библиотеку затронет не только пользователей рассматриваемой системы, но и вообще всех пользователей Kotlin.
\end{enumerate}

В данном случае, логично как раз воспользоваться тем фактом, что в пользовательском коде обычно встречаются именно интерфейсы коллекций: достаточно определить свою реализацию коллекции и копировать данные в неё при вызове \texttt{.share()}.
Компилятор же будет считать, что интерфейс \texttt{List} является разделяемым по значению.
Точно такой же подход применим к \texttt{Set} и \texttt{Map}.

Все разделяемые реализации коллекций будут удовлетворять стандартным контрактам своих интерфейсов, за исключением изменяющих методов (таких как \texttt{add}, \texttt{remove}, и т. д.): такие методы будут бросать исключение.
Данный подход аналогичен поведению коллекции после вызова \texttt{java.util.Collections.unmodifiableCollection}. Данный метод можно даже использовать в качестве детали реализации на JVM, однако для JS и Native всё равно придётся писать собственный аналог.


\section{Механизм расширения компилятора}\label{codegen}

Рассмотрим, каким именно способом можно внести предлагаемые изменения в компилятор. Отметим, что их объем достаточно большой: требуется и применить специальную стратегию для кодогенерации, чтобы трансформировать код для разделяемых по значению классов, и ввести множество дополнительных проверок в компилятор.
Внесение крупных изменений может повлечь возникновение ошибок как и в новой функциональности, так и, при неудачном стечении обстоятельств, старой, что крайне нежелательно.
Поэтому необходимо максимально отделить код, реализующий данную систему, от основного компилятора, с точки зрения инфраструктуры, а так же сделать его легко отключаемым: если у пользователя возникнут проблемы с новой системой, её будет возможно просто отключить без переписывания кода.

Все поставленные задачи будут решены, если реализовывать предложенную систему с помощью плагина к компилятору: плагины могут быть включены и отключены в любой момент, имеют ограниченную степень влияния на внутренности компилятора, а само ядро компилятора при этом не может иметь зависимости на код из плагинов.
У компилятора Kotlin в данный момент существует API плагинов, который не является документируемым и рекомендуемым для пользователей, однако им вполне можно пользоваться. Из данного API для целей работы представляют интерес следующие точки расширения:

\begin{enumerate}
	\item \texttt{SyntheticResolveExtension} --- точка расширения, которая предоставляет возможности для доопределения синтетических методов в классе. Через неё возможно добавить метод \texttt{.share()} к методам класса так, чтобы он не отличался от метода, который был бы написан пользователем.
	\item Точка расширения, которая позволяет добавить свой \texttt{DeclarationChecker} --- анализатор деклараций, который будет проверять декларации классов на соответствие новым правилам (например на то, что наследник разделяемого по значению класса также разделяем по значению).
	\item \texttt{IrGenerationExtension} --- точка расширения, которая позволяет встроиться в процесс кодогенерации. С её помощью осуществляется трансформация сеттеров класса, разделяемого по значению, и имплементация метода \texttt{.share()}.
\end{enumerate}

Про способ кодогенерации стоит сделать отдельное замечание. На момент написания данной работы в инфраструктуре компилятора Kotlin проводятся внутренние изменения, направленные на унификацию компиляции между всеми тремя платформами: JVM, JS и Native.
Исторически сложилось так, что синтаксическое дерево кода на Kotlin напрямую транслировалось в код целевой платформы. Сейчас же цель рефакторинга состоит в том, чтобы код на Kotlin сначала переводился в некоторое внутреннее представление, называемое \textit{Intermediate Representation} (IR или backend IR). Это делается для того, чтобы переиспользовать и не дублировать логику общих для всех целевых платформ трансформаций, таких как оптимизация циклов или трансформация \texttt{suspend}-функций.
К общим трансформациям, очевидно, относится и трансформация, предлагаемая в данной работе. Поэтому логично проводить данную трансформацию, пользуясь IR, а не генерируя напрямую байткод целевой платформы. Данную функциональность как раз и предоставляет точка расширения \texttt{IrGenerationExtension}. Таким образом, функциональность плагина достаточно реализовать один раз и она будет одинаково работать на всех целевых платформах.

Помимо трансформации самого пользовательского кода, описанной в работе системе требуются некоторые декларации, видимые пользователю и/или доступные во время исполнения: аннотации, которые непосредственно используются для разметки классов (\texttt{@Shared} и \texttt{@SharedByValue}) и специфичные реализации коллекций, описанные в п. \ref{collections}.
Данные декларации размещены в библиотеке времени выполнения. Библиотека создана с использованием стандартных для экосистемы мультиплатформенной Kotlin-разработки средств: система сборки Gradle, плагин системы сборки \texttt{kotlin-multiplatform} для сборки проекта и плагин \texttt{maven-publish} для её публикации.
Соответственно, процесс её разработки, отладки и публикации ничем не отличается от любой другой библиотеки.
Единственный возможный недостаток --- переименовывание ключевых сущностей требует изменений как в библиотеке, так и в плагине, при этом релизный цикл плагина совпадает с самим компилятором и не может зависеть от библиотеки. При грамотном планировании это не должно стать серьезной проблемой.

\section{Анализ накладных расходов}

В данном разделе постараемся проанализировать, насколько влияет на производительность применение предложенной автором трансформации к коду.
Для начала следует понять, какой сценарий использования будет наиболее распространён.
Разделяемые по значению классы, как следует из их названия, предполагается использовать для безопасной передачи данных между потоками или независимыми частями программы. То есть, типовой сценарий жизненного цикла класса выглядит примерно так:

\begin{enumerate}
	\item Начальный владелец создает и инициализирует экземпляр класса
	\item Владелец работает с экземпляром, изменяя его данные (например, использует как внутреннее состояние)
	\item При необходимости, у экземпляра вызывается \texttt{.share()}, и после этого, в правильно написанной программе, из новой копии данные только читаются.
\end{enumerate}


Можно предположить, что в большинстве случаев количество чтений гораздо больше количества записей, а количество записей больше, чем количество глубоких копирований (вызовов \texttt{.share()}).
Именно это и происходит в случае, например, использования такого класса как внутреннего состояния и применения defensive copy при отдаче его наружу для просмотра.

Теперь рассмотрим, какие накладные расходы к вышеупомянутым операциям добавляет предлагаемая в данной работе трансформация кода.
Так как геттеры свойств никак не трансформируются, на чтение данных из объекта никаких дополнительных расходов нет.
Переходим к сеттерам: в каждом из них появляется дополнительная проверка флага. Заметим, что флаг является монотонным: сначала он имеет значение \texttt{false}, потом (при вызове \texttt{share}) его значение единожды меняется на \texttt{true} и не меняется в дальнейшем.
Это позволяет рассчитывать на то, что в современных процессорах при таком поведении хорошо будет срабатывать алгоритм предсказания ветвлений, и влияние этой условной проверки будет минимальным.
Метод \texttt{share} является действительно дорогим для выполнения: при его вызове выполняется глубокое копирование, которое занимает линейное время относительно количества объектов в подграфе. Однако из предположений, сделанных в предыдущем абзаце, можно сделать вывод, что данный метод будет вызываться не слишком часто.

Таким образом, при оптимистичном сценарии использования (количество чтений >{}> количества записей > количества вызовов \texttt{.share()})
общие накладные расходы должен быть не очень значительными.


\chapterconclusion

В данной главе были рассмотрены детали реализации рассматриваемого решения и изложены решения таких технических проблем, как: копирование подграфа объектов с циклами и ромбами, копирование экземпляров классов, возможность наследования разделяемых классов друг от друга и их возможности по реализации интерфейсов.
Были рассмотрены способы реализовать предложенные изменения в структуре компилятора Kotlin и было доказано, что оптимальным способом внести такие изменения будет их реализация в виде плагина к компилятору, работающая с внутренним промежуточным представлением (IR).
Также были проанализированы возможные накладные расходы при исполнении кода, трансформированного предложенным в работе способом, и доказано, что при оптимальном сценарии использования они будут незначительными.  


%% Макрос для заключения. Совместим со старым стилевиком.
\startconclusionpage

Целью данной работы являлась разработка нового механизма для языка Kotlin, который бы позволяет обеспечивать более точный контроль над неизменяемостью объектов.
В ходе работы автором были определены проблемы, которые должны быть решены, такие как неудобство программирования с исключительно финальными свойствами в объектах и невозможность разделения API класса на изменяющее и неизменяющее без введения дополнительных интерфейсов.
Также были проанализированы решения, существующие в других языках, и показано, что наилучшим способом решить поставленные задачи в рамках языка Kotlin будет совмещение проверок времени исполнения и проверок времени компиляции.
Была предложено разделение классов на несколько категорий и трансформация кода для одной из категорий, которая бы осуществляла необходимые проверки времени исполнения, а также описаны необходимые проверки в компиляторе.
В ходе работы были рассмотрены решения различных технических проблем, такие как циклы в подграфах объектов и наследование классов разных категорий разделяемости. Было проанализировано влияние предлагаемых изменений на производительность.

По результатам работы был сделан вывод, что предложенный механизм решает все поставленные задачи и может быть реализован в виде комбинации плагина к компилятору Kotlin и библиотеки времени выполнения.
Решение будет в дальнейшем внедряться в различные популярные библиотеки с открытым исходным кодом, чтобы собрать опыт применения на больших проектах и обратную связь от пользователей.


\printmainbibliography

%% После этой команды chapter будет генерировать приложения, нумерованные русскими буквами.
%% \startappendices из старого стилевика будет делать то же самое
%\appendix

%\chapter{Пример приложения}\label{sec:app:1}

\end{document}
